---
title: "Работа с С-объединениями (union) в Rust FFI"
author: Herman J. Radtke III (перевёл Станислав Ткач)
categories: обучение
excerpt: >
   При создании биндингов к коду на С мы неизбежно столкнёмся со структурой, которая содержит в себе объединение. В Rust 
   отсутствует встроенная поддержка объединений, так что нам придётся выработать стратегию самостоятельно. В С объединение
   — это тип, который хранит разные типы данных в одной области памяти. Существует много причин, по которым можно отдать
   предпочтение объединению, такие как: преобразование между бинарными представлениями целых чисел и чисел с плавающей
   точкой, реализация псевдо-полиморфизма и прямой доступ к битам. Я сфокусируюсь на псевдо-полиморфизме.
---

Предлагаю вашему вниманию перевод статьи "[Working with C unions in Rust FFI](http://hermanradtke.com/2016/03/17/unions-rust-ffi.html)" за авторством Herman J. Radtke III.

Примечание: Эта статья предполагает, что читатель знаком с [Rust FFI](https://doc.rust-lang.org/book/ffi.html), [порядком байтов](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2) (endianess) и [ioctl](https://en.wikipedia.org/wiki/Ioctl).

При создании биндингов к коду на С мы неизбежно столкнёмся со структурой, которая содержит в себе объединение. В Rust 
отсутствует встроенная поддержка объединений, так что нам придётся выработать стратегию самостоятельно. В С объединение - 
это тип, который хранит разные типы данных в одной области памяти. Существует много причин, по которым можно отдать 
предпочтение объединению, такие как: преобразование между бинарными представлениями целых чисел и чисел с плавающей 
точкой, реализация псевдо-полиморфизма и прямой доступ к битам. Я сфокусируюсь на псевдо-полиморфизме.

Как пример, давайте получим MAC адрес, основанный на имени интерфейса. Перечислим действия, необходимые для его получения:
- Указать тип запроса, который будет использоваться с ioctl. Если я хочу получить MAC (или аппаратный) адрес, я указываю SIOCGIFHWADDR.
- Записать имя интерфейса (что-то типа eth0) в ifr_name.
- Сделать запрос, используя ioctl. В результате удачного запроса данные запишутся в ifr_ifru.

Если вас интересуют детали о получении MAC адреса, посмотрите эту [инструкцию](http://www.microhowto.info/howto/get_the_mac_address_of_an_ethernet_interface_in_c_using_siocgifhwaddr.html).
 
Нам необходимо использовать объявленную в С ioctl функцию и передать туда ifreq структуру. Посмотрев в 
/usr/include/net/if.h, мы увидим, что ifreq определена следующим образом:
```c
struct  ifreq {
        char    ifr_name[IFNAMSIZ];
        union {
                struct  sockaddr ifru_addr;
                struct  sockaddr ifru_dstaddr;
                struct  sockaddr ifru_broadaddr;
                short   ifru_flags;
                int     ifru_metric;
                int     ifru_mtu;
                int     ifru_phys;
                int     ifru_media;
                int     ifru_intval;
                caddr_t ifru_data;
                struct  ifdevmtu ifru_devmtu;
                struct  ifkpi   ifru_kpi;
                u_int32_t ifru_wake_flags;
                u_int32_t ifru_route_refcnt;
                int     ifru_cap[2];
        } ifr_ifru;
}
```

Сложности возникают с объединением ifr_ifru. Взглянув на возможные типы в ifr_ifru, мы видим, что не все из них 
одинакового размера. short занимает два байта, а u_int32_t — четыре. Ещё больше усложняют ситуацию несколько структур 
неизвестного размера. Чтобы написать правильный код на Rust, важно выяснить точный размер ifreq структуры. Я создал 
небольшую программу на С и выяснил, что ifreq использует 16 байт для ifr_name и 24 байт для ifr_ifru.
  
Вооружившись знаниями о правильном размере структуры, мы можем начать представлять её в Rust. Одна из стратегий — создать 
специализированную структуру для всех типов объединения. 
    
```rust
#[repr(C)]
pub struct IfReqShort {
    ifr_name: [c_char; 16],
    ifru_flags: c_short,
}
```

Мы можем использовать IfReqShort для запроса SIOCGIFINDEX. Эта структура меньше, чем ifreq структура в С. Хотя мы и 
предполагаем, что будет записано только 2 байта, внешний ioctl интерфейс ожидает 24 байта. Для безопасности давайте 
добавим 22 байта выравнивания (padding) в конце:

```rust
#[repr(C)]
pub struct IfReqShort {
    ifr_name: [c_char; 16],
    ifru_flags: c_short,
    _padding: [u8; 22],
}
```

Затем мы должны будем повторить этот процесс для каждого типа в объединении. Я нахожу это несколько утомительным, так как 
нам придётся создать множество структур и быть очень внимательными, чтобы не ошибиться с их размером. Другой способ 
представить объединение — это иметь буфер сырых байтов. Мы можем сделать единственное представление структуры ifreq в Rust следующим образом:
 
```rust
#[repr(C)]
pub struct IfReq {
    ifr_name: [c_char; 16],
    union: [u8; 24],
}
 ```
 
Этот буфер-объединение может хранить байты любого типа. Теперь мы можем определить методы для преобразования сырых байтов 
в нужный тип. Мы избежим использования небезопасного (unsafe) кода, отказавшись от использования transmute. Давайте 
создадим метод для получения MAC адреса, преобразовав сырые байты в sockaddr C-тип.
 
```rust
impl IfReq {
    pub fn ifr_hwaddr(&self) -> sockaddr {
        let mut s = sockaddr {
            sa_family: u16::from_be((self.data[0] as u16) << 8 | (self.data[1] as u16)),
            sa_data: [0; 14],
        };

        // basically a memcpy
        for (i, b) in self.data[2..16].iter().enumerate() {
            s.sa_data[i] = *b as i8;
        }

        s
    }
}
```

Такой подход оставляет нам одну структуру и метод для преобразования сырых байтов в желаемый тип. Посмотрев снова на наше 
ifr_ifru объединение, мы обнаружим, что существует по крайней мере два других запроса, которые тоже требуют создания 
sockaddr из сырых байтов. Применяя принцип DRY, мы можем реализовать приватный метод IfReq для преобразования сырых байтов в sockaddr. Однако, мы можем сделать лучше, абстрагировав детали создания sockaddr, short, int и т.д. от IfReq. Всё что 
нам необходимо — это сказать объединению, что нам нужен определённый тип. Давайте создадим IfReqUnion для этого:
 
```rust
#[repr(C)]
struct IfReqUnion {
    data: [u8; 24],
}

impl IfReqUnion {
    fn as_sockaddr(&self) -> sockaddr {
        let mut s = sockaddr {
            sa_family: u16::from_be((self.data[0] as u16) << 8 | (self.data[1] as u16)),
            sa_data: [0; 14],
        };

        // basically a memcpy
        for (i, b) in self.data[2..16].iter().enumerate() {
            s.sa_data[i] = *b as i8;
        }

        s
    }

    fn as_int(&self) -> c_int {
        c_int::from_be((self.data[0] as c_int) << 24 |
                       (self.data[1] as c_int) << 16 |
                       (self.data[2] as c_int) <<  8 |
                       (self.data[3] as c_int))
    }

    fn as_short(&self) -> c_short {
        c_short::from_be((self.data[0] as c_short) << 8 |
                         (self.data[1] as c_short))
    }
}
```

Мы реализовали методы для каждого из типов, которые составляют объединение. Теперь, когда наши преобразования управляются 
IfReqUnion, мы можем реализовать методы IfReq следующим образом:

```rust
#[repr(C)]
pub struct IfReq {
    ifr_name: [c_char; IFNAMESIZE],
    union: IfReqUnion,
}

impl IfReq {
    pub fn ifr_hwaddr(&self) -> sockaddr {
        self.union.as_sockaddr()
    }

    pub fn ifr_dstaddr(&self) -> sockaddr {
        self.union.as_sockaddr()
    }

    pub fn ifr_broadaddr(&self) -> sockaddr {
        self.union.as_sockaddr()
    }

    pub fn ifr_ifindex(&self) -> c_int {
        self.union.as_int()
    }

    pub fn ifr_media(&self) -> c_int {
        self.union.as_int()
    }

    pub fn ifr_flags(&self) -> c_short {
        self.union.as_short()
    }
}
```

В итоге у нас есть две структуры. Во первых, IfReq, которая представляет структуру памяти ifreq в языке С. В ней мы 
реализуем метод для каждого типа ioctl запроса. Во вторых, у нас есть IfRequnion, которая управляет различными типами 
объединения ifr_ifru. Мы создадим метод для каждого типа, который нам нужен. Это менее трудоёмко, чем создание 
специализированной структуры для каждого типа объединения, и предоставляет лучший интерфейс, чем преобразование типа в 
самой IfReq.
 
Вот более полный готовый [пример](https://github.com/hjr3/carp-rs/blob/5d56a62b1a698949a7252db637d3fbeadbb62e3b/src/mac.rs
). Предстоит ещё немного работы, но тесты проходят, и в коде реализуется описанная выше концепция.
  
Будьте осторожны, этот подход не идеален. В случае ifreq нам повезло, что ifr_name содержит 16 байтов и выровнено по 
границе слова. Если бы ifr_name не было выровнено по границе четырёхбайтного слова, мы столкнулись бы с проблемой. Тип 
нашего объединения [u8; 24], которое выравнивается по границе одного байта. У типа размером 24 байта было бы другое 
выравнивание. Вот короткий пример иллюстрирующий проблему. Допустим, у нас есть С-структура, содержащая следующее 
объединение:
   
```c
struct foo {
    short x;
    union {
        int;
    } y;
}
```

Эта структура имеет размер 8 байт. Два байта для х, ещё два для выравнивания и четыре байта для у. Давайте попробуем 
изобразить это в Rust:
 
```rust
#[repr(C)]
pub struct Foo {
    x: u16,
    y: [u8; 4],
}
```

Структура Foo имеет размер только 6 байт: два байта для х и первые два u8 элемента, помещённые в то же четырёхбайтовое 
слово, что и х. Эта едва заметная разница может вызвать проблемы при передаче в С-функцию, которая ожидает структуру 
размеров в 8 байт.
 
До тех пор пока Rust не будет поддерживать объединения, такие проблемы сложно будет решить корректно. Удачи, но будьте 
осторожны! 
  
*Примечание переводчика: уже существует [несколько](https://github.com/retep998/rfcs/blob/master/text/0000-unsafe-enums.md) [предложений](https://github.com/joshtriplett/rfcs/blob/untagged_union/text/0000-union.md) по добавлению нужной функциональности в язык.*
